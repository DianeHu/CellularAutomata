CompSci 308: Cell Society Design Document
===================

### Introduction
We're trying to solve the problem of creating a interface capable of animating several different cellular automata simulations where different simulation have different cell behaviors necessitating different parameters. The design must be flexible in adding new simulations and modifying the behavior of current simulations. The design must also be flexible in allowing the user to change simple parameters of the input. The user should be able to upload certain XML files, so they have control over all data controlled through the XML file. However, once the file is uploaded, at the moment they have no control over any parameters of the simulation. This may change in the future. 
### Overview
The main component of the program will be a Simulation class, will includes the game loop and user interface details. The Simulation class creates an instance of the Grid class, which has parameters of the XML file which describes the simulation, and the root for the scene. The Grid class creates an instance of an XMLReader with a parameter of an xml file. This XMLReader reads the XML file to return all the values required for the simulation to be run; it has several getter methods which parse the XML file for certain values. The Grid class then creates cells based on the information from XML reader, and adds the grid of cells to the scene through the root. The Grid class maintains a 2D array of Cells, and thus is able to update each cell's list of neighbors. There's a Cell abstract superclass, and the different types of cells from the different simulations will be subclasses. For example, there will be BlackCell, WhiteCell, FishCell, SharkCell, TreeCell, EmptyCell, etc. Cell methods, which would be implemented differently for each subtype, include moveNewLoc() to figure out where to move to the next location, killCell() to remove the cell and replace it with an EmptyCell, createCell() to reproduce, and isNeighbor() to see whether input coordinates correspond to a cell which counts as a neighbor by simulation rules. Each cell has an instance variable of an ArrayList of Neighbor cells which the Grid class updates with every step. This list is used when the cell makes decisions about what actions to undertake. The Grid class will go through its 2D array of Cells in its method updateGrid() to have each cell move to a new location or perform another action based on its neighbors.  The Grid class also ensures that each step of the simulation is being accurately visualized on the screen, using Cell instance variable of images used to represent them. The Cell classes purposes are to describe the behavior of each type of simulation, while the Grid class's purpose is to go update the entire simulation based on each cell's behavior. In essence, the Grid class manages the cells so that they all function together.
![How the Components are Related](doc/componentRelations.JPG)
![Our Specific Classes Part1](doc/classes1.JPG)
![Our Specific Classes Part2](doc/classes2.JPG)
### User Interface
 Our “Simulation” class will handle our user input. The first user input would be under a screen that prompts “Upload Configuration” which would necessitate an XML filename to be typed in which would call our “handleKeyInputSplash” method. Through another class “XMLReader”, we would check to see if any parameters are missing or if file is incorrectly formatted. This would send out a “bad input” or “incorrect format” error message. Another error message would be “Unknown filename” if the file inputted could not be found. The next screen would prompt “Choose Simulation Type” giving a list of all our simulation types. The input to choose the simulation would be clickable buttons on the screen which would be call our “handleMouseInputSplash” method. During the simulation, we would accept user key input and mouse input in our “handleKeyInput” method and “handleMouseInput” method respectively. 
![User Interface](doc/userInterface.JPG)
### Design Details
(See images included) The design overview covers parameter and return details of how components interact with each other, so the following is a description of how our design could be extended. Our Grid class in particular is meant to be flexible, and to be able to take in any simulation and run. In order to do so, Grid will have to call methods from the Cell superclass, which themselves will be specifically overridden by Cell subclasses. Extending simulations would largely require adding more Cell subclasses that specify how those specific cells should behave, and specifying in the initial configuration in the XML file that those cells should be used, and in what locations. The GUI should be extended via the Simulation main driver class, which may call subclasses that control button design/label design, etc., in the future. In this way, users/future programmers should be able to extend our CellSociety program to include more simulations mainly by adding cells, and changing configurations/adding the option to select new configurations through the GUI.
 - Apply the rules to a middle cell
	 - First of all, the Grid cell will plug in the coordinates of all adjacent positions that are within the dimensions of the 2D array of Cells into the Cell method isNeighbor(). If this returns true, then the cell with the adjacent coordinates is added to the middle cell's list of neighbors. If the number of live neighbors from this list is less than 2, or if there are more than 3 live neighbors, then the LiveCell is killed, and a DeadCell is created in its place. 
 - Apply the rules to an edge cell
 	 - First of all, the Grid cell will plug in the coordinates of all adjacent positions that are within the dimensions of the 2D array of Cells into the Cell method isNeighbor(). If this returns true, then the cell with the adjacent coordinates is added to the middle cell's list of neighbors. If the number of live neighbors is 2 to 3, then if the cell is a LiveCell, nothing happens. If the cell is a DeadCell, and 3 neighbors are LiveCells, the DeadCell is killed and a LiveCell is created in its place. 
 - Move to the next generation
	 - The grid goes through each cell in its 2D array and has the cell complete its actions and return information about the cell's new location and any new cells created. This information is used to create a new 2D array which replaces the old 2D array. This new 2D array is used to visualize the next step of the simulation.
 - Set a simulation parameter 
	 - The XMLReader will go through the XML file to get the value and then returns it to the Grid class.
 - Switch simulations
	 - The user will click on a key which will cause a function to be called which brings the user back to the home screen where they can select the simulation type. The grid that they get when they click play will be the grid that they had when they paused the simulation/chose to go back to the home screen to reselect simulation type.

The Cell class was created in order to encapsulate the rules for each simulation within cell subclasses so that adding a new simulation would only include adding new cell subclasses. Each cell uses the same methods, but these methods are implemented very differently. The XMLReader was created so that the Grid class would have an easy way of accessing relevant values without having to do the work to get them. This splits responsibility and makes the Grid class solely focused on managing cells and making sure the cells are all acting in parallel.  The Grid class was created to be as generalized as possible so that it acts the same regardless of simulation type. This makes the code more flexible so that new simulations can easily be added. The Simulation class's function is to cover all user interface details and to call the Grid class. All important information about the simulation is hidden from the Simulation class. 

### Design Considerations
One issue our group discussed was whether to have empty cell locations as truly empty in the scene, or to fill them with an EmptyCell class. We considered whether it would be easier to determine if a cell had empty neighboring spots it could move into if those spots were truly empty, or filled with the Empty class. For now, we are going to move forward with the EmptyCell subclass--we decided it might be easier to check instanceof to determine emptiness, rather than whether or not the location had any other cell in it. This way, when cells die off, we can simply replace their location with EmptyCell cells as well. This method may necessitate more code in creating the class, as compared to the other method, but overall it should make the rest of the design easier to read. We also discussed how we wanted the Grid class to look like, and whether Grid should have subclasses for different simulations. Ultimately, we decided that while it might be easier to have different subclasses, it would be best if we could make Grid as flexible as possible, so that extending future simulations can be easier.

### Team Responsibilities
**Tyler Yam** - Primary responsibility is user interface, focusing on the Simulation class. Secondary responsibility is figuring out how to write XML files and implementing the XML reader.
**Madhavi Rajiv** - Primary responsibility is working on cell subclasses for 2 simulations (Wator and Segregation), and secondary responsibility is working on the Grid class.
**Diane Hu** - Primary responsibility is working on cell subclasses for 2 simulations (Game of Life and Spreading of Fire), and secondary responsibility is working on the Grid class.

Overall, we're planning on checking in in person about once a day to see how our code fits together. We'll work together in person so that we don't write unnecessary code or code which doesn't fit in with another class.