Cell Society Design File
===================
#### mr284, dh224, tjy8
Madhavi, Diane, Tyler

### High Level Design Goals
The high level design goals of this project was to create a project where adding new simulations would require very little extra code or logic or refactoring, and where adding new GUI features would require only editing a small part of the code. The project attempted to do this by creating inheritance hierarchies for all front end components to separate out the generalized code and specific code for each simulation. In this way, adding a new simulation only requires adding a small amount of simulation specific code for each feature. Another goal of our project was to encapsulate different features as much as possible from one another. We tried to create the XML Reading, the GUI and Visualization, and the Backend logic for each simulation as much as possible.

###  How to add new features
In order to add a new simulation, it's necessary to create a new subclass for Simulation, Graph, XMLReader, and GridConfiguration. All of these subclasses will be very similar in format to existing subclasses; however they must be modified to account for different thresholds, user input fields, cell name labels, and other simulation specific minutiae. Also, new Cells subclasses must be added to account for each cell's interaction behavior, and a new map for the simulation must be created in grid mapping certain characters to certain specific cell types. Note that all cells take three thresholds to set, since all the simulations we made had at max three thresholds that had to be live updated. If less than three thresholds or no thresholds need to be set for a certain simulation, the cell will just have the setThresholds method as a do-nothing. 

In Grid, add the new simulation type to the appropriate maps--the gridConfigString map that has what each cell type should be read as when exporting, the general simulation map that pairs characters with cell types, and the counts map that tracks counts of certain cells. Add the appropriate counting methods that track cell counts. In the switch statement selecting the right map to instantiate cells, add the case of your String simulation type, corresponding to switching the current simulation map to the map specific to your simulation. Finally, in main class, a text input string which is taken from the user must be mapped to the right Simulation subclass.

In order to add new features to the style document, it's necessary to modify the StyleReader and StyleConfiguration classes to get more arguments. Then the main class will read these arguments and send the additional arguments to the Simulation class, which will send these arguments to the Grid class.

In order to add a new GUI feature, a new inheritance hierarchy could be created for it if it differed based on the specification of the simulation, and the right subtype of the feature's class would be initialized in the corresponding Simulation subclass. If the feature isn't simulation specific, an instance of its class and its method calls could simply be added to the Simulation superclass.

Allowing infinite grids would require using an 2 dimensional arraylist instead of array in order to keep track of the cells. The neighbors given to cells would include a padding around the existing grid, so that each cell would have the option to move outside the existing grid. The grid would be resized in terms of dimensions if a cell decided to move outside the existing grid. The shapes corresponding to the cells would also be resized according to the size of the grid at each update, and the 2D arraylist would get another arraylist added in the row and column directions as the grid expanded.

Adding a new shape such as triangle would require adding an additional Grid subclass which dealt with the unique initialization of triangle polygons, and the unique neighbor situation of Triangles. It would also require adding new features to the style document, a process described earlier.

###  Justification of Major Design Choices

A major design choice was having main class used to take the css styling XML and simulation type and calling a simulation subclass. The different simulations each have their own front-end subclass. The main draw to having subclasses was to allow for multiple different simulations to run at the same time. Having the subclasses also made it easier to create stages with text fields that were specific to the simulation. These text fields were designed so that the user could change a parameter of a simulation on the fly. A drawback to having subclasses was we would have to add a subclass for each new simulation, even if there was overlap between some subclasses, as long as there was anything different between the two, such as different textfields. The majority of their code would belong in the superclass still, but if there’s any difference between simulations, those parts would have to be extracted into subclasses.

A similar design choice was making the XML reader and exporter has subclasses for each simulation type as opposed having one type of XML for all simulations. The pro of creating subclasses was that we were able to tailor each XML to the simulation instead of storing values that would not be needed for a simulation. The drawbacks to have the subclasses is there was slightly more code in general. Again there was some overlap between subclasses and even some that did not differ from the super class at all. However as a team, we thought this would be the best route so that the user would only need to create an XML with the input they need to test. It’s possible we could have created an XML reader that read all the common items, and called some sort of threshold object to read the simulation specific items, but we ended up doing it the way we did because it seemed cleaner since we already had multiple simulation subclasses.

Another design choice made for the front end was how we made buttons. There was two factors for making buttons that influenced the methods. One factor was whether or not the buttons were returnable. After speaking with Professor Duvall, he noted that a button should only be stored in the main method if we would need to change the button after a user touched it, like disabling the button. For times when we did not need to change a button, it was a better design to not store it in the main. So we would only use a returnable button when would change some feature of the button and used a void method when we would not change the button. The other factor that influenced the methods was whether or not the button would be stored in a VBox or HBox. At first we tried to make a parameter a regular box to reduce duplicate code, but unfortunately this would cause errors. Thus we had to duplicate the code so that we could store the buttons in their respective box type.

Finally, our team had a disagreement over how to design the Cells as a superclass. One approach was to make Cell an interface, have abstract simulation classes under that interface, and concrete instantiations of simulation cells under that. The benefit of this approach would be that more duplicated code could be removed, since Cell as an interface would contain nothing simulation specific, and the simulation specific code could be contained in the abstract simulation classes, with the cells having even less code than they have now. However, we eventually decided to stick with Cell as an abstract superclass and all the cells as its subclasses. It was a model that was working already, and there wasn’t that much duplicated code to begin with in the cell subclasses. We didn’t know if refactoring this area of the project to this extent would be worth the time that it would take at the end of the day, especially if it resulted in hard-to-find bugs. Additionally, we ended up extracting some methods from the Cell class to the Grids anyways, which removed some of the duplicated code we had initially disagreed about.

### Assumptions or Decisions To Resolve Functionality
We assumed that simulations would have at most three thresholds for users to set. All the simulations we saw/were trying to run had at most three, and it seemed unlikely to come across a cellular automata with more, since the majority of CA behavior is modelled off rules that only marginally depend on thresholds. We therefore focused more on implementing a more flexible model for dictating cell behavior/movement, and for setting thresholds, gave a method for setting threshold with three parameters--cell.setThreshold(double a, double b, double c). Users would set the ones they needed, and leave the others alone with a filler double. For example, SpreadingWildfire simulations have a probGrow and a probCatch, so the setThreshold call would contain (probGrow, probCatch, 0), and no calls would be made with the 0, thus defining no behavior for the third threshold.

We also assumed that in setting simulation initial states, users would be able to use the template XML testing files we provided in order to design their own. We assumed users would be able to draw the conclusion on their own to use the same characters we did to designate certain cell types, for example, otherwise the simulation maps in Grid wouldn’t work. If users added extra fields in their XML files, or didn’t fill out necessary ones, that would throw an error box telling them their file was invalid, and we assumed users would be able to see that error and realize they needed to go back and fix their files.

We also assumed that the user would know how to correctly spell the simulation types to start the simulations. Even though an error is thrown when an incorrect simulation type is entered, it would be had for the user to guess the correct simulation type without prior knowledge. We did explore the option of a menu button, but we did not have enough time to fully pursue this option. We also ran out of time for trying to make a splash screen with instructions for how to operate our program. Thus we placed all of this information into the readME and assumed that the user would read it before attempting to use the program.